unit PSE.Data.Model;

interface

uses
  System.SysUtils,
  Spring,
  Spring.Persistence.Mapping.Attributes;

type
  TStockStatus = (Up, Down, Unchanged);

  [Entity]
  [Table('STOCKS')]
  TStockModel = class
  private
    fSymbol: string;
    fPercentChange: single;
    fLastTradedPrice: single;
    fDescription: string;
    fVolume: single;
    fStatus: TStockStatus;
    fLastUpdateDateTime: TDateTime;
  public
    constructor Create;
    [Column('SYMBOL', [cpRequired, cpPrimaryKey])]
    property Symbol: string read fSymbol write fSymbol;
    [Column('DESCRIPTION')]
    property Description: string read fDescription write fDescription;
    property LastTradedPrice: single read fLastTradedPrice write fLastTradedPrice;
    property PercentChange: single read fPercentChange write fPercentChange;
    property Volume: single read fVolume write fVolume;
    property Status: TStockStatus read fStatus write fStatus;
    property LastUpdateDateTime: TDateTime read fLastUpdateDateTime write fLastUpdateDateTime;
  end;

  [Entity]
  [Table('INTRADAY')]
  TIntradayModel = class
  private
    fSymbol: string;
    fPercentChange: single;
    fPrice: single;
//    fValue: single;
    fVolume: single;
    fStockStatus: TStockStatus;
  public
    [Column('SYMBOL', [cpRequired, cpPrimaryKey])]
    property Symbol: string read fSymbol write fSymbol;
    [Column('PRICE')]
    property Price: single read fPrice write fPrice;
    [Column('PCTCHANGE')]
    property PercentChange: single read fPercentChange write fPercentChange;
    [Column('VOLUME')]
    property Volume: single read fVolume write fVolume;
    [Column('STATUS')]
    property Status: TStockStatus read fStockStatus write fStockStatus;
  end;

  TStockHeaderModel = class
  private
    fSymbol: string;
    fFiftyTwoWeekLow: single;
    fTotalVolume: int64;
    fTotalValue: int64;
    fChangeClose: single;
    fCurrentPE: single;
    fLastTradedDate: TDateTime;
    fPreviousClose: single;
    fFiftyTwoWeekHigh: single;
    fIntradayLow: single;
    fLastTradedPrice: single;
    fAvgPrice: single;
    fIntradayOpen: single;
    fIntradayHigh: single;
    fChangeClosePercentage: single;
  public
    constructor Create;
    property Symbol: string read fSymbol write fSymbol;
    property FiftyTwoWeekHigh: single read fFiftyTwoWeekHigh write fFiftyTwoWeekHigh;
    property FiftyTwoWeekLow: single read fFiftyTwoWeekLow write fFiftyTwoWeekLow;
    property PreviousClose: single read fPreviousClose write fPreviousClose;
    property ChangeClose: single read fChangeClose write fChangeClose;
    property ChangeClosePercentage: single read fChangeClosePercentage write fChangeClosePercentage;
    property LastTradedDate: TDateTime read fLastTradedDate write fLastTradedDate;
    property LastTradedPrice: single read fLastTradedPrice write fLastTradedPrice;
    property TotalValue: int64 read fTotalValue write fTotalValue;
    property TotalVolume: int64 read fTotalVolume write fTotalVolume;
    property IntradayLow: single read fIntradayLow write fIntradayLow;
    property IntradayHigh: single read fIntradayHigh write fIntradayHigh;
    property IntradayOpen: single read fIntradayOpen write fIntradayOpen;
    property AvgPrice: single read fAvgPrice write fAvgPrice;
    property CurrentPE: single read fCurrentPE write fCurrentPE;
  end;

  TPriceTriggerType = (Below, Equal, Above, BelowEqual, AboveEqual);

  TLogicType = (None=0, LogicOr=1, LogicAND=2);

  [Entity]
  [Table('ALERTS')]
  TAlertModel = class
  private
    fStock: string;
    fCreatedDateTime: TDateTime;
    FNotes: string;
    FAlertCount: integer;
    FMaxAlertCount: integer;
    FPrice: single;
    FPriceTriggerType: TPriceTriggerType;
    FVolume: single;
    FLogic: TLogicType;
    procedure SetLogic(const Value: TLogicType);
    procedure SetPrice(const Value: single);
    procedure SetPriceTriggerType(const Value: TPriceTriggerType);
    procedure SetVolume(const Value: single);
//    procedure SetPriceTrigger(const Value: TPriceTrigger);
    procedure SetStock(const Value: string);
//    procedure SetVolumeTrigger(const Value: TVolumeTrigger);
    procedure SetNotes(const Value: string);
    procedure SetAlertCount(const Value: integer);
    procedure SetMaxAlertCount(const Value: integer);
    function GetPriceTriggerDescription: string;
    function GetVolumeTriggerDescription: string;
  private
    [Column('ID', [cpRequired, cpPrimaryKey, cpNotNull, cpDontInsert], 0, 0, 0, 'Primary Key')]
    [AutoGenerated]
    fId: Integer;
  public
    constructor Create;
    destructor Destroy; override;

    property ID: Integer read FId write FId;
    [Column('SYMBOL', [cpNotNull])]
    property StockSymbol: string read fStock write SetStock;
    property CreatedDateTime: TDateTime read fCreatedDateTime write fCreatedDateTime;

    [Column('PRICE')]
    property Price: single read FPrice write SetPrice;
    [Column('PRICELEVEL')]
    property PriceTriggerType: TPriceTriggerType read FPriceTriggerType write SetPriceTriggerType;
    [Column('VOLUME')]
    property Volume: single read FVolume write SetVolume;
    [Column('VOL_CONJUNCT')]
    property Logic: TLogicType read FLogic write SetLogic;
    [Column('ALERT_COUNT')]
    property AlertCount: integer read FAlertCount write SetAlertCount;
    [Column('MAX_ALERT')]
    property MaxAlertCount: integer read FMaxAlertCount write SetMaxAlertCount;
    [Column('NOTES')]
    property Notes: string read FNotes write SetNotes;
    property PriceTriggerDescription: string read GetPriceTriggerDescription;
    property VolumeTriggerDescription: string read GetVolumeTriggerDescription;
    function CanTrigger: boolean;
  end;

implementation

uses
  TypInfo, StrUtils;


{ TStockModel }

constructor TStockModel.Create;
begin
  fPercentChange := 0;
  fLastTradedPrice := 0;
  fVolume := 0;
end;

function TAlertModel.CanTrigger: boolean;
begin
  result := fAlertCount < fMaxAlertCount;
end;

constructor TAlertModel.Create;
begin
//  FPriceTrigger := TPriceTrigger.Create;
//  FVolumeTrigger := TVolumeTrigger.Create;
  fLogic := TLogicType.None;
  FAlertCount := 0;
  FMaxAlertCount := 10;
end;

destructor TAlertModel.Destroy;
begin
  inherited;
end;

function TAlertModel.GetPriceTriggerDescription: string;
begin
  result := 'Trigger alert when the price is ';
  if PriceTriggerType = TPriceTriggerType.BelowEqual then
    result := result + 'Below/Equal'
  else
  if PriceTriggerType = TPriceTriggerType.AboveEqual then
    result := result + 'Above/Equal'
  else
    result := result + GetEnumName(TypeInfo(TPriceTriggerType), integer(FPriceTriggerType));
  result := result + ' ' + FloatToStr(FPrice);
end;

function TAlertModel.GetVolumeTriggerDescription: string;
begin

  if FLogic <> TLogicType.None then
  begin
    result := ReplaceStr(GetEnumName(TypeInfo(TLogicType), integer(FLogic)), 'Logic', string.Empty).Trim;
    result := result +' when volume is at least ' + FloatToStr(FVolume);
  end

end;

procedure TAlertModel.SetAlertCount(const Value: integer);
begin
  FAlertCount := Value;
end;

procedure TAlertModel.SetLogic(const Value: TLogicType);
begin
  FLogic := Value;
end;

procedure TAlertModel.SetMaxAlertCount(const Value: integer);
begin
  FMaxAlertCount := Value;
end;

procedure TAlertModel.SetNotes(const Value: string);
begin
  FNotes := Value;
end;

procedure TAlertModel.SetPrice(const Value: single);
begin
  FPrice := Value;
end;

//procedure TAlertModel.SetPriceTrigger(const Value: TPriceTrigger);
//begin
//  FPriceTrigger := Value;
//end;

procedure TAlertModel.SetPriceTriggerType(const Value: TPriceTriggerType);
begin
  FPriceTriggerType := Value;
end;

procedure TAlertModel.SetStock(const Value: string);
begin
  fStock := Value;
end;

procedure TAlertModel.SetVolume(const Value: single);
begin
  FVolume := Value;
end;

//procedure TAlertModel.SetVolumeTrigger(const Value: TVolumeTrigger);
//begin
//  FVolumeTrigger := Value;
//end;

//{ TVolumeTrigger }
//
//function TVolumeTrigger.GetDescription: string;
//begin
//
//end;
//
//procedure TVolumeTrigger.SetLogic(const Value: TLogicType);
//begin
//  FLogic := Value;
//end;
//
//procedure TVolumeTrigger.SetVolume(const Value: single);
//begin
//  FVolume := Value;
//end;
//
//function TVolumeTrigger.ToString: string;
//begin
//  if FLogic <> TLogicType.None then
//  begin
//    result := ReplaceStr(GetEnumName(TypeInfo(TLogicType), integer(FLogic)), 'Logic', string.Empty).Trim;
//
//    result := result +' when volume is at least ' + FloatToStr(FVolume);
//  end;
//end;

{ TPriceTrigger }

//function TPriceTrigger.GetDescription: string;
//begin
//  result := ToString;
//end;
//
//procedure TPriceTrigger.SetPrice(const Value: single);
//begin
//  FPrice := Value;
//end;
//
//procedure TPriceTrigger.SetPriceTriggerType(const Value: TPriceTriggerType);
//begin
//  FPriceTriggerType := Value;
//end;
//
//function TPriceTrigger.ToString: string;
//begin
//  result := 'Trigger alert when the price is ';
//  if PriceTriggerType = TPriceTriggerType.BelowEqual then
//    result := result + 'Below/Equal'
//  else
//  if PriceTriggerType = TPriceTriggerType.AboveEqual then
//    result := result + 'Above/Equal'
//  else
//    result := result + GetEnumName(TypeInfo(TPriceTriggerType), integer(FPriceTriggerType));
//  result := result + ' ' + FloatToStr(FPrice);
//end;

{ TStockHeaderModel }

constructor TStockHeaderModel.Create;
begin
  fSymbol := '';
  fFiftyTwoWeekLow := 0;
  fTotalVolume := 0;
  fTotalValue := 0;
  fChangeClose := 0;
  fCurrentPE := 0;
  fLastTradedDate := 0;
  fPreviousClose := 0;
  fFiftyTwoWeekHigh := 0;
  fIntradayLow := 0;
  fLastTradedPrice := 0;
  fAvgPrice := 0;
  fIntradayOpen := 0;
  fIntradayHigh := 0;
  fChangeClosePercentage := 0;
end;

end.
